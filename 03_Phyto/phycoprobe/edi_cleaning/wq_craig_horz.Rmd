1/13/2025

initial cleaning of horizontal WQ data

Title: Phycoprobe Data - Monthly Cleaning

By: Perry

```{r}
# ---
# EDIT THIS
# ---

# declare the run year of interest
year <- 2023
```

```{r}
# ---
# CODE STARTS HERE
# ---

# import packages
library(tidyverse)
library(lubridate)
library(deltamapr)
library(leaflet)
library(shinyFiles)
library(leaflet.extras)
library(plotly)
library(readxl)
library(shiny)
library(sf)
library(sp)
source('03_Phyto/phycoprobe/functions/phyco_funcs.R')

# read in run names and regions
df_names <- read_csv('03_Phyto/phycoprobe/supp_files/run_names.csv', show_col_types = FALSE)

# obtain all filepaths and create combo df
fp_all_wq <- archive_path(2023, 'MOPED')

df_combo <- create_combo_df(fp_all_wq)

df_list <- list()

# run code for all combos
for(i in 1:nrow(df_combo)){
  # define variables
  month <- df_combo[i,]$month
  run <- df_combo[i,]$run
  
  print(glue::glue('month: {month} and run: {run}'))
  
  # read in WQ data
  fp_wq <- data_path(run, month, year, type = 'MOPED')
  df_wq <- read_csv(fp_wq, skip = 2, show_col_types = FALSE)
  df_wq1 <- read_csv(fp_wq, skip = 2, show_col_types = FALSE)
  df_wq$TimeStamp <- parse_date_time(df_wq$TimeStamp, c('mdY HMS', 'mdY HM'))
  df_wq$TimeStamp <- as.POSIXct(df_wq$TimeStamp, format = '%m/%d/%Y %H:%M:%S')
  
  df_wq$Analyte <- paste0(df_wq$Header,'_',df_wq$Unit)

  df_wq <- df_wq %>%
    subset(select = c(Longitude, Latitude, TimeStamp, Analyte, Value)) %>%
    rename(DateTime = TimeStamp) %>%
    pivot_wider(
      names_from = Analyte,
      values_from = Value,
      values_fn = list(Value = ~ mean(.x, na.rm = TRUE))
    ) %>%
    select(-SONDEDEPTH_ft) %>%
    filter(!if_any(everything(), ~ .x == 0 | is.na(.x)))

  df_wq <- df_wq %>%
    mutate(RoundedDateTime = round_date(DateTime, 'minute')) %>%
    mutate(TimeDiff = abs(as.numeric(difftime(DateTime, RoundedDateTime, units = 'secs')))) %>%
    group_by(RoundedDateTime) %>%
    slice_min(order_by = TimeDiff, n = 1, with_ties = FALSE) %>%
    ungroup() %>%
    select(-c(DateTime, TimeDiff)) %>%
    rename(DateTime = RoundedDateTime)
  
  # filter out rows around Antioch
  lat_min <- 38.015465
  lat_max <- 38.032394
  lon_min <- -121.762379
  lon_max <- -121.741878

  df_wq <- df_wq %>%
  filter(!(Latitude >= lat_min & Latitude <= lat_max &
             Longitude >= lon_min & Longitude <= lon_max))

  # convert date/time col back to character
  df_wq$DateTime <- as.character(df_wq$DateTime)
  
  # export
  fn_exp <- str_remove(str_extract(fp_wq, '[^/]*$'), '.txt')
  
  fp_folder <- create_dir(year)
  fp_exp <- paste0(fp_folder,'/',fn_exp,'_summary.csv')
  
  # write_csv(df_final, fp_exp)

  df_list[[i]] <- df_wq
}

# Combine all dataframes into one
df_month <- bind_rows(df_list)

# write_csv(df_wq, 'C:/Users/sperry/Desktop/wq_test.csv')
```

```{r}
# plot data
df_month$DateTime <- as.POSIXct(df_month$DateTime, format = '%Y-%m-%d %H:%M:%S')

analyte_cols <- colnames(df_month)[!colnames(df_month) %in% c('Longitude', 'Latitude', 'DateTime')]

create_plt <- function(df, analyte_col) {
  max_y <- max(df[[analyte_col]], na.rm = TRUE)
  
  plot_ly(
    data = df,
    x = ~DateTime,
    y = as.formula(paste0('~`', analyte_col, '`')),
    type = 'scatter',
    mode = 'markers',
    marker = list(size = 6, opacity = 0.7),
    name = analyte_col
  ) %>%
    layout(
      title = paste(analyte_col),
      xaxis = list(title = 'DateTime'),
      yaxis = list(title = analyte_col, range = c(0, max_y))
    )
}

plts <- list()
for (col in analyte_cols) {
  plt <- create_plt(df_month, col)
  print(plt)
  plts[[col]] <- plt
}
```

```{r}
# create leaflet maps
df_month$DateTime <- as.POSIXct(df_month$DateTime, format = '%Y-%m-%d %H:%M:%S')

create_map <- function(df, x_col, y_col = 'DateTime') {
  leaflet(data = df) %>%
    addTiles() %>%
    addCircles(
      lng = ~Longitude, 
      lat = ~Latitude,
      color = ~colorNumeric('viridis', df[[x_col]])(df[[x_col]]),
      popup = ~paste0('<b>', x_col, ':</b> ', df[[x_col]], '<br>',
                      '<b>', y_col, ':</b> ', df[[y_col]])
    ) %>%
    addLegend('bottomright', 
              pal = colorNumeric('viridis', df[[x_col]]), 
              values = df[[x_col]],
              title = x_col,
              opacity = 1)
}

analyte_cols <- colnames(df_month)[!colnames(df_month) %in% c('Longitude', 'Latitude', 'DateTime')]

for (col in analyte_cols) {
  print(create_map(df_month, col))
}
```

```{r}
# create shiny app for removing points
ui <- fluidPage(
  titlePanel('Remove Suspect Values'),
  sidebarLayout(
    sidebarPanel(
      fileInput(
        inputId = 'file',
        label = 'Upload CSV File',
        accept = c('.csv')
      ),
      uiOutput('analyte_selector'),
      actionButton('remove', 'Remove Points'),
      textInput(
        inputId = 'file_name',
        label = 'File Name',
        value = 'edited_data.csv',
        placeholder = 'Specify file name to save output'
      ),
      shinyDirButton(
        id = 'output_dir',
        label = 'Select Output Folder',
        title = 'Choose folder to save the file'
      ),
      actionButton('save', 'Save Edited CSV')
    ),
    mainPanel(
      plotlyOutput('plot'),
      tableOutput('tbl_selected_pts')
    )
  )
)

server <- function(input, output, session) {
  # define root directories
  roots <- c(home = normalizePath('~'),  C = 'C:/')
  shinyDirChoose(input, 'output_dir', roots = roots, session = session)

  df_react <- reactiveVal(NULL)
  selected_pts <- reactiveVal(NULL)
  output_dir <- reactiveVal(NULL)

  # load data from uploaded file
  observeEvent(input$file, {
    req(input$file)
    df <- read.csv(input$file$datapath)
    df_react(df)
  })

  # store selected output dir
  observe({
    req(input$output_dir)
    output_dir(parseDirPath(roots = roots, input$output_dir))
  })

  # generate the analyte selector
  output$analyte_selector <- renderUI({
    req(df_react())
    selectInput(
      inputId = 'analyte',
      label = 'Analyte:',
      choices = setdiff(names(df_react()), c('DateTime', 'Longitude', 'Latitude'))
    )
  })

  # get selected analyte
  analyte <- reactive({
    req(input$analyte)
    input$analyte
  })

  # render plot
  output$plot <- renderPlotly({
    req(df_react(), analyte())
    plot_ly(
      data = df_react(),
      x = ~DateTime,
      y = as.formula(paste0('~`', analyte(), '`')),
      type = 'scatter',
      mode = 'markers',
      marker = list(size = 6, opacity = 0.7),
      key = ~seq_len(nrow(df_react()))
    ) %>%
      layout(
        title = paste(analyte()),
        xaxis = list(title = 'DateTime'),
        yaxis = list(title = analyte())
      )
  })

  # update selected points to NA
  observeEvent(input$remove, {
    req(df_react(), analyte())
    selected <- event_data('plotly_selected')

    if (!is.null(selected)) {
      updated_rows <- selected$key
      df_updated <- df_react()
      df_updated[updated_rows, analyte()] <- NA
      df_react(df_updated)
      selected_pts(df_updated[updated_rows, ])
      showNotification(paste(length(updated_rows), 'points updated to NA'), type = 'message')
    } else {
      showNotification('No points selected', type = 'warning')
    }
  })

  # render table
  output$tbl_selected_pts <- renderTable({
    req(selected_pts())
    selected_pts()
  })

  # save the edited data to .csv
  observeEvent(input$save, {
    req(df_react(), output_dir(), input$file_name)
    output_path <- file.path(output_dir(), input$file_name)
    write.csv(df_react(), output_path, row.names = FALSE)
    showNotification(paste('File saved to', output_path), type = 'message')
  })
}

shinyApp(ui, server)
```




